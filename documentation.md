# Мок-сервер для фронтенд-разработки

Типизированный мок-сервер на Express для имитации бэкенд-API. Маршруты строятся автоматически по структуре папок в `env/`, что позволяет быстро добавлять и изменять эндпоинты без правки ядра приложения.

---

## Содержание

- [Технологический стек](#-технологический-стек)
- [Структура проекта](#-структура-проекта)
- [Запуск](#-запуск)
- [Архитектура: как устроены маршруты](#-архитектура-как-устроены-маршруты)
- [Конфигурация окружений](#-конфигурация-окружений)
- [Добавление и изменение эндпоинтов](#-добавление-и-изменение-эндпоинтов)
- [Сценарии ответов (x-scenario)](#-сценарии-ответов-x-scenario)
- [Подключение к фронтенд-приложению](#-подключение-к-фронтенд-приложению)
- [Типичные задачи и советы](#-типичные-задачи-и-советы)

---

## Технологический стек

| Компонент | Технология | Назначение |
|-----------|------------|------------|
| Язык | **TypeScript 5.9** | Типизация, надёжность кода |
| HTTP-сервер | **Express 5.2** | Обработка запросов и маршрутизация |
| Данные | **Faker 5.5** | Генерация тестовых данных (при необходимости) |
| Сборка | **tsc-watch** | Пересборка и перезапуск при изменении файлов |
| Очистка | **rimraf** | Удаление `dist` перед сборкой |

---

## Структура проекта

```
ProjectTemplateFrontendSpaReact-mock-server/
├── index.ts              # Точка входа: сканирование env, создание приложений, регистрация маршрутов
├── package.json
├── tsconfig.json
├── env/                  # Окружения (каждое = отдельный порт и префикс API)
│   ├── api/              # Основное API (порт 9001, префикс /api/)
│   │   ├── config.ts     # port, routePrefix для этого окружения
│   │   └── routes/       # Дерево маршрутов → URL
│   │       ├── v1/
│   │       │   ├── auth/
│   │       │   │   ├── login.ts   → POST /api/v1/auth/login
│   │       │   │   └── otp.ts     → POST /api/v1/auth/otp
│   │       │   ├── module1/
│   │       │   │   └── list.ts    → GET /api/v1/module1/list
│   │       │   └── module2/
│   │       │       └── list.ts    → GET /api/v1/module2/list
│   │       └── v2/
│   │           └── ...
│   └── ibfl/             # Другое API (порт 9011, префикс /ibfl/)
│       ├── config.ts
│       └── routes/
│           └── v1/
│               └── accounts/
│                   └── list.ts    → GET /ibfl/v1/accounts/list
└── dist/                 # Скомпилированный JS (создаётся при запуске)
```

- **`env/<имя_окружения>/`** — одна папка = один Express-сервер со своим портом и префиксом.
- **`env/<имя_окружения>/config.ts`** — порт и `routePrefix` для этого окружения.
- **`env/<имя_окружения>/routes/`** — дерево папок и файлов, из которого строятся URL и привязка к методам (GET, POST, DELETE и т.д.).

---

## Запуск

```bash
# Установка зависимостей (один раз)
npm install

# Запуск в режиме разработки (пересборка при изменении файлов)
npm start
```

При старте выполняются:

1. `npm run clean` — удаление папки `dist`.
2. Запуск `tsc-watch`: компиляция TypeScript и при успехе — `node dist/index.js`.
3. При любом изменении `.ts`-файлов сборка и процесс перезапускаются.

В консоли будут строки вида:

- `Found envs - [ 'api', 'ibfl' ]`
- `Initiate env - api` / `Initiate env - ibfl`
- `Found config - api { port: 9001, routePrefix: '/api/' }`
- `Found routes module - login` и `Start listen - POST /api/v1/auth/login`

По ним можно проверить, какие окружения и какие маршруты подняты.

---

## Архитектура: как устроены маршруты

### Общая схема

1. **Сканирование `env/`**  
   Все подпапки первого уровня (`api`, `ibfl`, …) считаются отдельными окружениями.

2. **Конфиг окружения**  
   Для каждой подпапки загружается `config.ts`: из него берутся `port` и `routePrefix`. По умолчанию в коде: `port: 9001`, `routePrefix: ''`.

3. **Рекурсивный обход `routes/`**  
   Папки задают сегменты URL, файлы — конечный сегмент и привязку к HTTP-методам.

4. **Имя файла → сегмент пути**  
   Берётся имя файла без расширения (`.ts` или `.js`). Например, `login.ts` → сегмент `login`.

5. **Экспорты модуля → HTTP-методы**  
   В файле экспортируются функции с именами: `get`, `post`, `put`, `patch`, `del` (для DELETE) и т.д. Они регистрируются как обработчики для соответствующего метода на построенном пути.

### Пример соответствия «файл → URL»

| Файл | Экспорты | Итоговый маршрут |
|------|----------|-------------------|
| `env/api/routes/v1/auth/login.ts` | `post` | `POST /api/v1/auth/login` |
| `env/api/routes/v1/module1/list.ts` | `get` | `GET /api/v1/module1/list` |
| `env/ibfl/routes/v1/accounts/list.ts` | `get` | `GET /ibfl/v1/accounts/list` |

Полный путь = **routePrefix** + путь по папкам + **имя файла без расширения**.

### Важно про метод DELETE

В коде Express метод называется `delete`, но это зарезервированное слово в JS. В мок-сервере для DELETE используется экспорт с именем **`del`** — при регистрации он автоматически превращается в `app.delete(...)`.

---

## Конфигурация окружений

Файл: `env/<окружение>/config.ts`.

Формат:

```ts
export default {
    port: 9001,           // Порт, на котором слушает это приложение
    routePrefix: '/api/'  // Префикс для всех маршрутов этого окружения
}
```

- **port** — один порт на одно окружение (например, `api` — 9001, `ibfl` — 9011).
- **routePrefix** — как правило, слэш в начале и в конце (`/api/`). Внутри он разбивается по `/`, пустые части отфильтровываются и собираются в начало пути.

Чтобы добавить новое окружение:

1. Создать папку `env/<новое_имя>/`.
2. Добавить `config.ts` с `port` и `routePrefix`.
3. Создать папку `routes/` и в ней — нужную структуру папок и файлов-обработчиков.

После перезапуска (`npm start`) новое окружение поднимется автоматически.

---

## Добавление и изменение эндпоинтов

### Новый эндпоинт (пошагово)

**Задача:** добавить `GET /api/v1/products/list`.

1. Выбрать окружение (например, `api`) и мысленно пройти путь: `api` → `v1` → `products` → `list`.
2. Создать каталоги при необходимости:
   - `env/api/routes/v1/products/`
3. Создать файл `env/api/routes/v1/products/list.ts`:

```ts
import { RequestHandler } from 'express';

export const get: RequestHandler = async (req, res) => {
    res.json([
        { id: 1, title: 'Товар 1' },
        { id: 2, title: 'Товар 2' },
    ]);
};
```

4. Сохранить файл. После пересборки в логе появится что-то вроде: `Start listen - GET /api/v1/products/list`.

### Несколько методов в одном файле

Один и тот же путь может обрабатывать разные методы (GET и POST и т.д.) — достаточно экспортировать несколько обработчиков:

```ts
import { RequestHandler } from 'express';

export const get: RequestHandler = async (req, res) => {
    res.json({ items: [] });
};

export const post: RequestHandler = async (req, res) => {
    res.status(201).json({ id: 1, ...req.body });
};
```

Имя файла задаёт сегмент пути; имена экспортов (`get`, `post`, `del`, …) — HTTP-методы.

### Чтение тела запроса и параметров

- **Тело (JSON):** после `app.use(express.json())` доступно в `req.body`.
- **Query:** `req.query` (например, `?page=1` → `req.query.page`).
- **Параметры маршрута:** в текущей реализации маршруты строятся только по статическим сегментам (без `:id`). Для путей вида `/api/v1/products/:id` потребовалось бы доработать ядро (например, поддержка специальых имён файлов или папок).

### Использование Faker

При необходимости можно генерировать данные через Faker:

```ts
import { RequestHandler } from 'express';
// для Faker v5: import faker from 'faker';
// для Faker v8+: import { faker } from '@faker-js/faker';

export const get: RequestHandler = async (req, res) => {
    const items = Array.from({ length: 5 }, (_, i) => ({
        id: i + 1,
        name: faker.company.companyName(),
        createdAt: faker.date.past(),
    }));
    res.json(items);
};
```

(Импорт и вызовы подставьте под установленную в проекте версию Faker.)

---

## Сценарии ответов (x-scenario)

Чтобы не менять код мока при проверке ошибок (400, 404, 500 и т.д.), используется механизм сценариев.

### Идея

- В запрос с фронтенда добавляется заголовок **`x-scenario`** (или значение берётся из другого места по договорённости).
- Обработчик в моке смотрит значение этого заголовка и возвращает нужный статус/тело (успех, ошибка, пустой ответ и т.д.).

### Хранение на фронтенде (localStorage)

На фронте можно хранить сценарий в `localStorage`, чтобы не прокидывать заголовок вручную в каждом запросе:

- **Ключ:** `method-<pathname>` (pathname без ведущего слэша, слэши заменены на дефисы).  
  Пример: для `GET /api/v1/module1/list` ключ: `GET-api-v1-module1-list`.
- **Значение:** имя сценария, например `http400`, `http500`, `empty`.

Фронтенд при отправке запроса читает этот ключ и подставляет заголовок `x-scenario: <значение>`.

### Пример в моке

```ts
import { RequestHandler } from 'express';

export const get: RequestHandler = async (req, res) => {
    const scenario = req.headers['x-scenario'] as string | undefined;

    if (scenario === 'http400') {
        res.status(400).json({ error: 'Bad Request' });
        return;
    }
    if (scenario === 'http500') {
        res.status(500).json({ error: 'Internal Server Error' });
        return;
    }

    res.json([{ id: 1, name: 'Item 1' }]);
};
```

Таким образом, переключая в localStorage значение для `GET-api-v1-module1-list` (или заголовок в запросе), можно проверять обработку ошибок на фронте без правки мока.

---

## Подключение к фронтенд-приложению

1. **Base URL**  
   В конфиге запросов фронта указать базовый адрес мока, например:
   - для API: `http://localhost:9001/api`
   - для IBFL: `http://localhost:9011/ibfl`

2. **Прокси (если фронт на dev-сервере)**  
   Можно настроить прокси на 9001/9011, чтобы запросы к относительным путям типа `/api/...` уходили на мок.

3. **CORS**  
   При запросах с другого порта (например, фронт на 3000, мок на 9001) может понадобиться включить CORS в моке (в `index.ts` добавить `app.use(cors())` и установить пакет `cors`).

---

## Типичные задачи и советы

### Посмотреть все зарегистрированные маршруты

Запустить `npm start` и посмотреть вывод: для каждого файла в `routes/` выводятся «Start listen - METHOD /path».

### Эндпоинт не срабатывает

- Проверить путь: он должен совпадать с `routePrefix` + папки + имя файла без расширения.
- Убедиться, что в файле экспортирована функция с именем метода в нижнем регистре (`get`, `post`, `del` и т.д.).
- Перезапустить мок после добавления/переименования файлов.

### Разные задержки ответа

В обработчике можно искусственно задержать ответ:

```ts
export const get: RequestHandler = async (req, res) => {
    await new Promise((r) => setTimeout(r, 2000));
    res.json({ data: 'slow' });
};
```

### Версионирование API

Уже используется в структуре папок: `v1`, `v2` и т.д. Достаточно копировать или создавать подпапки `v2/`, `v3/` в `routes/` и добавлять туда файлы — получатся пути вида `/api/v2/...`, `/api/v3/...`.
